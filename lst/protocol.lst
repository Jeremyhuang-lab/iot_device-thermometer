C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\output\protocol.obj
COMPILER INVOKED BY: E:\Keil5 MDK1\C51\BIN\C51.EXE mcu_sdk\protocol.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\mcu_s
                    -dk) DEBUG PRINT(.\lst\protocol.lst) OBJECT(.\output\protocol.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.6
  11           * @date    2020.12.16
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          /****************************** å…è´£å£°æ˜ ï¼ï¼ï¼ *******************************
  20          ç”±äºMCUç±»å‹å’Œç¼–è¯‘ç¯å¢ƒå¤šç§å¤šæ ·ï¼Œæ‰€ä»¥æ­¤ä»£ç ä»…ä¾›å‚è€ƒï¼Œç”¨æˆ·è¯·è‡ªè¡ŒæŠŠæ§æœ€ç»ˆä»£ç
             - è´¨é‡ï¼Œ
  21          æ¶‚é¸¦ä¸å¯¹MCUåŠŸèƒ½ç»“æœè´Ÿè´£ã€‚
  22          ******************************************************************************/
  23          
  24          /******************************************************************************
  25                                          ç§»æ¤é¡»çŸ¥:
  26          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  27          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  28          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  29          ******************************************************************************/
  30          
  31          #include "wifi.h"
  32          
  33          #ifdef WEATHER_ENABLE
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 2   

                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
                  "pm10",
                  "o3",
                  "no2",
                  "co",
                  "conditionNum",*/
              };
              #endif
  63          
  64          
  65          /******************************************************************************
  66                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  67          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
  68          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
  69          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  70          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  71          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
  72          ******************************************************************************/
  73          
  74          /******************************************************************************
  75                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  76                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  77          ******************************************************************************/
  78          const DOWNLOAD_CMD_S download_cmd[] =
  79          {
  80            {DPID_TEMP_CURRENT, DP_TYPE_VALUE},
  81            {DPID_HUMIDITY_VALUE, DP_TYPE_VALUE},
  82            {DPID_BATTERY_STATE, DP_TYPE_ENUM},
  83            {DPID_BATTERY_PERCENTAGE, DP_TYPE_VALUE},
  84            {DPID_TAMPER_ALARM, DP_TYPE_BOOL},
  85            {DPID_TEMP_SAMPLING, DP_TYPE_VALUE},
  86            {DPID_HUMIDITY_SAMPLING, DP_TYPE_VALUE},
  87            {DPID_CHARGE_STATE, DP_TYPE_BOOL},
  88            {DPID_TEMP_UNIT_CONVERT, DP_TYPE_ENUM},
  89            {DPID_MAXTEMP_SET, DP_TYPE_VALUE},
  90            {DPID_MINITEMP_SET, DP_TYPE_VALUE},
  91            {DPID_MAXHUM_SET, DP_TYPE_VALUE},
  92            {DPID_MINIHUM_SET, DP_TYPE_VALUE},
  93            {DPID_TEMP_ALARM, DP_TYPE_ENUM},
  94            {DPID_HUM_ALARM, DP_TYPE_ENUM},
  95            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
  96            {DPID_TEMP_PERIODIC_REPORT, DP_TYPE_VALUE},
  97            {DPID_HUM_PERIODIC_REPORT, DP_TYPE_VALUE},
  98            {DPID_TEMP_SENSITIVITY, DP_TYPE_VALUE},
  99            {DPID_HUM_SENSITIVITY, DP_TYPE_VALUE},
 100            {DPID_SWITCH, DP_TYPE_BOOL},
 101            {DPID_TEMP_SET, DP_TYPE_VALUE},
 102          };
 103          
 104          
 105          
 106          /******************************************************************************
 107                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 108          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
 109          ******************************************************************************/
 110          
 111          /**
 112           * @brief  ä¸²å£å‘é€æ•°æ®
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 3   

 113           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
 114           * @return Null
 115           */
 116          void uart_transmit_output(unsigned char value)
 117          {
 118   1      //    #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 119   1          
 120   1          //Example:
 121   1          extern void Uart1_PutChar(unsigned char bdat);
 122   1          Uart1_PutChar(value);                                       //ä¸²å£å‘é€å‡½æ•°
 123   1      }
 124          
 125          /******************************************************************************
 126                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 127          1:APPä¸‹å‘æ•°æ®å¤„ç†
 128          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 129          ******************************************************************************/
 130          
 131          /******************************************************************************
 132                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 133          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 134            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 135            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 136            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 137          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 138          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 139          ******************************************************************************/
 140          
 141          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 142          
 143          /**
 144           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 145           * @param  Null
 146           * @return Null
 147           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 148           */
 149          void all_data_update(void)
 150          {
 151   1      //    #error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 152   1          
 153   1          //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸Šæ
             -Š¥å‡½æ•°
 154   1      //    mcu_dp_value_update(DPID_TEMP_CURRENT,200); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 155   1      //    mcu_dp_value_update(DPID_HUMIDITY_VALUE,200); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 156   1          mcu_dp_enum_update(DPID_BATTERY_STATE,1); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 157   1          mcu_dp_value_update(DPID_BATTERY_PERCENTAGE,20); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 158   1          mcu_dp_bool_update(DPID_TAMPER_ALARM,0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 159   1          mcu_dp_value_update(DPID_TEMP_SAMPLING,1); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 160   1          mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,1); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 161   1          mcu_dp_bool_update(DPID_CHARGE_STATE,0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 162   1          mcu_dp_enum_update(DPID_TEMP_UNIT_CONVERT,0); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 163   1          mcu_dp_value_update(DPID_MAXTEMP_SET,250); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 164   1          mcu_dp_value_update(DPID_MINITEMP_SET,250); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 165   1          mcu_dp_value_update(DPID_MAXHUM_SET,250); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 166   1          mcu_dp_value_update(DPID_MINIHUM_SET,250); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 167   1          mcu_dp_enum_update(DPID_TEMP_ALARM,10); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 168   1          mcu_dp_enum_update(DPID_HUM_ALARM,10); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 169   1          mcu_dp_value_update(DPID_BRIGHT_VALUE,0); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 170   1          mcu_dp_value_update(DPID_TEMP_PERIODIC_REPORT,2); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 171   1          mcu_dp_value_update(DPID_HUM_PERIODIC_REPORT,2); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 172   1          mcu_dp_value_update(DPID_TEMP_SENSITIVITY,2); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 4   

 173   1          mcu_dp_value_update(DPID_HUM_SENSITIVITY,2); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 174   1          mcu_dp_bool_update(DPID_SWITCH,1); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 175   1          mcu_dp_value_update(DPID_TEMP_SET,0); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 176   1      
 177   1          
 178   1      }
 179          
 180          
 181          /******************************************************************************
 182                                          WARNING!!!    
 183                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 184          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 185          ******************************************************************************/
 186          /*****************************************************************************
 187          å‡½æ•°åç§° : dp_download_temp_sampling_handle
 188          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SAMPLINGçš„å¤„ç†å‡½æ•°
 189          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 190                  : length:æ•°æ®é•¿åº¦
 191          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 192          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 193          *****************************************************************************/
 194          static unsigned char dp_download_temp_sampling_handle(const unsigned char value[], unsigned short length)
 195          {
 196   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 197   1          unsigned char ret;
 198   1          unsigned long temp_sampling;
 199   1          
 200   1          temp_sampling = mcu_get_dp_download_value(value,length);
 201   1          /*
 202   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 203   1          
 204   1          */
 205   1          
 206   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 207   1          ret = mcu_dp_value_update(DPID_TEMP_SAMPLING,temp_sampling);
 208   1          if(ret == SUCCESS)
 209   1              return SUCCESS;
 210   1          else
 211   1              return ERROR;
 212   1      }
 213          /*****************************************************************************
 214          å‡½æ•°åç§° : dp_download_humidity_sampling_handle
 215          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUMIDITY_SAMPLINGçš„å¤„ç†å‡½æ•°
 216          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 217                  : length:æ•°æ®é•¿åº¦
 218          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 219          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 220          *****************************************************************************/
 221          static unsigned char dp_download_humidity_sampling_handle(const unsigned char value[], unsigned short leng
             -th)
 222          {
 223   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 224   1          unsigned char ret;
 225   1          unsigned long humidity_sampling;
 226   1          
 227   1          humidity_sampling = mcu_get_dp_download_value(value,length);
 228   1          /*
 229   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 230   1          
 231   1          */
 232   1          
 233   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 5   

 234   1          ret = mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,humidity_sampling);
 235   1          if(ret == SUCCESS)
 236   1              return SUCCESS;
 237   1          else
 238   1              return ERROR;
 239   1      }
 240          /*****************************************************************************
 241          å‡½æ•°åç§° : dp_download_temp_unit_convert_handle
 242          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_UNIT_CONVERTçš„å¤„ç†å‡½æ•°
 243          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 244                  : length:æ•°æ®é•¿åº¦
 245          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 246          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 247          *****************************************************************************/
 248          static unsigned char dp_download_temp_unit_convert_handle(const unsigned char value[], unsigned short leng
             -th)
 249          {
 250   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 251   1          unsigned char ret;
 252   1          unsigned char temp_unit_convert;
 253   1          
 254   1          temp_unit_convert = mcu_get_dp_download_enum(value,length);
 255   1          switch(temp_unit_convert) {
 256   2              case 0:
 257   2              break;
 258   2              
 259   2              case 1:
 260   2              break;
 261   2              
 262   2              default:
 263   2          
 264   2              break;
 265   2          }
 266   1          
 267   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 268   1          ret = mcu_dp_enum_update(DPID_TEMP_UNIT_CONVERT, temp_unit_convert);
 269   1          if(ret == SUCCESS)
 270   1              return SUCCESS;
 271   1          else
 272   1              return ERROR;
 273   1      }
 274          /*****************************************************************************
 275          å‡½æ•°åç§° : dp_download_maxtemp_set_handle
 276          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXTEMP_SETçš„å¤„ç†å‡½æ•°
 277          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 278                  : length:æ•°æ®é•¿åº¦
 279          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 280          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 281          *****************************************************************************/
 282          static unsigned char dp_download_maxtemp_set_handle(const unsigned char value[], unsigned short length)
 283          {
 284   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 285   1          unsigned char ret;
 286   1          unsigned long maxtemp_set;
 287   1          
 288   1          maxtemp_set = mcu_get_dp_download_value(value,length);
 289   1          /*
 290   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 291   1          
 292   1          */
 293   1          
 294   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 6   

 295   1          ret = mcu_dp_value_update(DPID_MAXTEMP_SET,maxtemp_set);
 296   1          if(ret == SUCCESS)
 297   1              return SUCCESS;
 298   1          else
 299   1              return ERROR;
 300   1      }
 301          /*****************************************************************************
 302          å‡½æ•°åç§° : dp_download_minitemp_set_handle
 303          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINITEMP_SETçš„å¤„ç†å‡½æ•°
 304          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 305                  : length:æ•°æ®é•¿åº¦
 306          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 307          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 308          *****************************************************************************/
 309          static unsigned char dp_download_minitemp_set_handle(const unsigned char value[], unsigned short length)
 310          {
 311   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 312   1          unsigned char ret;
 313   1          unsigned long minitemp_set;
 314   1          
 315   1          minitemp_set = mcu_get_dp_download_value(value,length);
 316   1          /*
 317   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 318   1          
 319   1          */
 320   1          
 321   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 322   1          ret = mcu_dp_value_update(DPID_MINITEMP_SET,minitemp_set);
 323   1          if(ret == SUCCESS)
 324   1              return SUCCESS;
 325   1          else
 326   1              return ERROR;
 327   1      }
 328          /*****************************************************************************
 329          å‡½æ•°åç§° : dp_download_maxhum_set_handle
 330          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXHUM_SETçš„å¤„ç†å‡½æ•°
 331          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 332                  : length:æ•°æ®é•¿åº¦
 333          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 334          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 335          *****************************************************************************/
 336          static unsigned char dp_download_maxhum_set_handle(const unsigned char value[], unsigned short length)
 337          {
 338   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 339   1          unsigned char ret;
 340   1          unsigned long maxhum_set;
 341   1          
 342   1          maxhum_set = mcu_get_dp_download_value(value,length);
 343   1          /*
 344   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 345   1          
 346   1          */
 347   1          
 348   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 349   1          ret = mcu_dp_value_update(DPID_MAXHUM_SET,maxhum_set);
 350   1          if(ret == SUCCESS)
 351   1              return SUCCESS;
 352   1          else
 353   1              return ERROR;
 354   1      }
 355          /*****************************************************************************
 356          å‡½æ•°åç§° : dp_download_minihum_set_handle
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 7   

 357          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINIHUM_SETçš„å¤„ç†å‡½æ•°
 358          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 359                  : length:æ•°æ®é•¿åº¦
 360          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 361          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 362          *****************************************************************************/
 363          static unsigned char dp_download_minihum_set_handle(const unsigned char value[], unsigned short length)
 364          {
 365   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 366   1          unsigned char ret;
 367   1          unsigned long minihum_set;
 368   1          
 369   1          minihum_set = mcu_get_dp_download_value(value,length);
 370   1          /*
 371   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 372   1          
 373   1          */
 374   1          
 375   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 376   1          ret = mcu_dp_value_update(DPID_MINIHUM_SET,minihum_set);
 377   1          if(ret == SUCCESS)
 378   1              return SUCCESS;
 379   1          else
 380   1              return ERROR;
 381   1      }
 382          /*****************************************************************************
 383          å‡½æ•°åç§° : dp_download_bright_value_handle
 384          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 385          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 386                  : length:æ•°æ®é•¿åº¦
 387          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 388          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 389          *****************************************************************************/
 390          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 391          {
 392   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 393   1          unsigned char ret;
 394   1          unsigned long bright_value;
 395   1          
 396   1          bright_value = mcu_get_dp_download_value(value,length);
 397   1          /*
 398   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 399   1          
 400   1          */
 401   1          
 402   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 403   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE,bright_value);
 404   1          if(ret == SUCCESS)
 405   1              return SUCCESS;
 406   1          else
 407   1              return ERROR;
 408   1      }
 409          /*****************************************************************************
 410          å‡½æ•°åç§° : dp_download_temp_periodic_report_handle
 411          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_PERIODIC_REPORTçš„å¤„ç†å‡½æ•°
 412          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 413                  : length:æ•°æ®é•¿åº¦
 414          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 415          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 416          *****************************************************************************/
 417          static unsigned char dp_download_temp_periodic_report_handle(const unsigned char value[], unsigned short l
             -ength)
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 8   

 418          {
 419   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 420   1          unsigned char ret;
 421   1          unsigned long temp_periodic_report;
 422   1          
 423   1          temp_periodic_report = mcu_get_dp_download_value(value,length);
 424   1          /*
 425   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 426   1          
 427   1          */
 428   1          
 429   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 430   1          ret = mcu_dp_value_update(DPID_TEMP_PERIODIC_REPORT,temp_periodic_report);
 431   1          if(ret == SUCCESS)
 432   1              return SUCCESS;
 433   1          else
 434   1              return ERROR;
 435   1      }
 436          /*****************************************************************************
 437          å‡½æ•°åç§° : dp_download_hum_periodic_report_handle
 438          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUM_PERIODIC_REPORTçš„å¤„ç†å‡½æ•°
 439          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 440                  : length:æ•°æ®é•¿åº¦
 441          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 442          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 443          *****************************************************************************/
 444          static unsigned char dp_download_hum_periodic_report_handle(const unsigned char value[], unsigned short le
             -ngth)
 445          {
 446   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 447   1          unsigned char ret;
 448   1          unsigned long hum_periodic_report;
 449   1          
 450   1          hum_periodic_report = mcu_get_dp_download_value(value,length);
 451   1          /*
 452   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 453   1          
 454   1          */
 455   1          
 456   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 457   1          ret = mcu_dp_value_update(DPID_HUM_PERIODIC_REPORT,hum_periodic_report);
 458   1          if(ret == SUCCESS)
 459   1              return SUCCESS;
 460   1          else
 461   1              return ERROR;
 462   1      }
 463          /*****************************************************************************
 464          å‡½æ•°åç§° : dp_download_temp_sensitivity_handle
 465          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SENSITIVITYçš„å¤„ç†å‡½æ•°
 466          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 467                  : length:æ•°æ®é•¿åº¦
 468          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 469          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 470          *****************************************************************************/
 471          static unsigned char dp_download_temp_sensitivity_handle(const unsigned char value[], unsigned short lengt
             -h)
 472          {
 473   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 474   1          unsigned char ret;
 475   1          unsigned long temp_sensitivity;
 476   1          
 477   1          temp_sensitivity = mcu_get_dp_download_value(value,length);
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 9   

 478   1          /*
 479   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 480   1          
 481   1          */
 482   1          
 483   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 484   1          ret = mcu_dp_value_update(DPID_TEMP_SENSITIVITY,temp_sensitivity);
 485   1          if(ret == SUCCESS)
 486   1              return SUCCESS;
 487   1          else
 488   1              return ERROR;
 489   1      }
 490          /*****************************************************************************
 491          å‡½æ•°åç§° : dp_download_hum_sensitivity_handle
 492          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUM_SENSITIVITYçš„å¤„ç†å‡½æ•°
 493          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 494                  : length:æ•°æ®é•¿åº¦
 495          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 496          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 497          *****************************************************************************/
 498          static unsigned char dp_download_hum_sensitivity_handle(const unsigned char value[], unsigned short length
             -)
 499          {
 500   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 501   1          unsigned char ret;
 502   1          unsigned long hum_sensitivity;
 503   1          
 504   1          hum_sensitivity = mcu_get_dp_download_value(value,length);
 505   1          /*
 506   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 507   1          
 508   1          */
 509   1          
 510   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 511   1          ret = mcu_dp_value_update(DPID_HUM_SENSITIVITY,hum_sensitivity);
 512   1          if(ret == SUCCESS)
 513   1              return SUCCESS;
 514   1          else
 515   1              return ERROR;
 516   1      }
 517          /*****************************************************************************
 518          å‡½æ•°åç§° : dp_download_switch_handle
 519          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCHçš„å¤„ç†å‡½æ•°
 520          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 521                  : length:æ•°æ®é•¿åº¦
 522          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 523          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 524          *****************************************************************************/
 525          static unsigned char dp_download_switch_handle(const unsigned char value[], unsigned short length)
 526          {
 527   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 528   1          unsigned char ret;
 529   1          //0:å…³/1:å¼€
 530   1          unsigned char switch_1;
 531   1          
 532   1          switch_1 = mcu_get_dp_download_bool(value,length);
 533   1          if(switch_1 == 0) {
 534   2              //å¼€å…³å…³
 535   2          }else {
 536   2              //å¼€å…³å¼€
 537   2          }
 538   1        
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 10  

 539   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 540   1          ret = mcu_dp_bool_update(DPID_SWITCH,switch_1);
 541   1          if(ret == SUCCESS)
 542   1              return SUCCESS;
 543   1          else
 544   1              return ERROR;
 545   1      }
 546          /*****************************************************************************
 547          å‡½æ•°åç§° : dp_download_temp_set_handle
 548          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SETçš„å¤„ç†å‡½æ•°
 549          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 550                  : length:æ•°æ®é•¿åº¦
 551          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 552          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 553          *****************************************************************************/
 554          static unsigned char dp_download_temp_set_handle(const unsigned char value[], unsigned short length)
 555          {
 556   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 557   1          unsigned char ret;
 558   1          unsigned long temp_set;
 559   1          
 560   1          temp_set = mcu_get_dp_download_value(value,length);
 561   1          /*
 562   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 563   1          
 564   1          */
 565   1          
 566   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 567   1          ret = mcu_dp_value_update(DPID_TEMP_SET,temp_set);
 568   1          if(ret == SUCCESS)
 569   1              return SUCCESS;
 570   1          else
 571   1              return ERROR;
 572   1      }
 573          
 574          
 575          
 576          
 577          /******************************************************************************
 578                                          WARNING!!!                     
 579          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 580          ******************************************************************************/
 581          
 582          /**
 583           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 584           * @param[in] {dpid} dpid åºå·
 585           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 586           * @param[in] {length} dpæ•°æ®é•¿åº¦
 587           * @return dpå¤„ç†ç»“æœ
 588           * -           0(ERROR): å¤±è´¥
 589           * -           1(SUCCESS): æˆåŠŸ
 590           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 591           */
 592          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 593          {
 594   1          /*********************************
 595   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 596   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 597   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 598   1          ***********************************/
 599   1          unsigned char ret;
 600   1          switch(dpid) {
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 11  

 601   2              case DPID_TEMP_SAMPLING:
 602   2                  //æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 603   2                  ret = dp_download_temp_sampling_handle(value,length);
 604   2              break;
 605   2              case DPID_HUMIDITY_SAMPLING:
 606   2                  //æ¹¿åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 607   2                  ret = dp_download_humidity_sampling_handle(value,length);
 608   2              break;
 609   2              case DPID_TEMP_UNIT_CONVERT:
 610   2                  //æ¸©æ ‡åˆ‡æ¢å¤„ç†å‡½æ•°
 611   2                  ret = dp_download_temp_unit_convert_handle(value,length);
 612   2              break;
 613   2              case DPID_MAXTEMP_SET:
 614   2                  //æ¸©åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 615   2                  ret = dp_download_maxtemp_set_handle(value,length);
 616   2              break;
 617   2              case DPID_MINITEMP_SET:
 618   2                  //æ¸©åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 619   2                  ret = dp_download_minitemp_set_handle(value,length);
 620   2              break;
 621   2              case DPID_MAXHUM_SET:
 622   2                  //æ¹¿åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 623   2                  ret = dp_download_maxhum_set_handle(value,length);
 624   2              break;
 625   2              case DPID_MINIHUM_SET:
 626   2                  //æ¹¿åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 627   2                  ret = dp_download_minihum_set_handle(value,length);
 628   2              break;
 629   2              case DPID_BRIGHT_VALUE:
 630   2                  //å½“å‰äº®åº¦å€¼å¤„ç†å‡½æ•°
 631   2                  ret = dp_download_bright_value_handle(value,length);
 632   2              break;
 633   2              case DPID_TEMP_PERIODIC_REPORT:
 634   2                  //æ¸©åº¦å‘¨æœŸä¸ŠæŠ¥å¤„ç†å‡½æ•°
 635   2                  ret = dp_download_temp_periodic_report_handle(value,length);
 636   2              break;
 637   2              case DPID_HUM_PERIODIC_REPORT:
 638   2                  //æ¹¿åº¦å‘¨æœŸä¸ŠæŠ¥å¤„ç†å‡½æ•°
 639   2                  ret = dp_download_hum_periodic_report_handle(value,length);
 640   2              break;
 641   2              case DPID_TEMP_SENSITIVITY:
 642   2                  //æ¸©åº¦çµæ•åº¦å¤„ç†å‡½æ•°
 643   2                  ret = dp_download_temp_sensitivity_handle(value,length);
 644   2              break;
 645   2              case DPID_HUM_SENSITIVITY:
 646   2                  //æ¹¿åº¦çµæ•åº¦å¤„ç†å‡½æ•°
 647   2                  ret = dp_download_hum_sensitivity_handle(value,length);
 648   2              break;
 649   2              case DPID_SWITCH:
 650   2                  //å¼€å…³å¤„ç†å‡½æ•°
 651   2                  ret = dp_download_switch_handle(value,length);
 652   2              break;
 653   2              case DPID_TEMP_SET:
 654   2                  //æ¸©åº¦è®¾ç½®å¤„ç†å‡½æ•°
 655   2                  ret = dp_download_temp_set_handle(value,length);
 656   2              break;
 657   2      
 658   2              
 659   2              default:
 660   2              break;
 661   2          }
 662   1          return ret;
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 12  

 663   1      }
 664          
 665          /**
 666           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 667           * @param[in] Null
 668           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 669           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 670           */
 671          unsigned char get_download_cmd_total(void)
 672          {
 673   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 674   1      }
 675          
 676          
 677          /******************************************************************************
 678                                          WARNING!!!                     
 679          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 680          ******************************************************************************/
 681          
 682          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
                      //å›ºä»¶æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
 722          
 723          #ifdef SUPPORT_GREEN_TIME
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 13  

              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 750          
 751          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 779          
 780          #ifdef WIFI_TEST_ENABLE
 781          /**
 782           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 783           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 784           * @ref       0: å¤±è´¥
 785           * @ref       1: æˆåŠŸ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 14  

 786           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 787           * @return Null
 788           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 789           */
 790          void wifi_test_result(unsigned char result,unsigned char rssi)
 791          {
 792   1      //    #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 793   1          if(result == 0) {
 794   2              //æµ‹è¯•å¤±è´¥
 795   2              if(rssi == 0x00) {
 796   3                  //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 797   3              }else if(rssi == 0x01) {
 798   3                  //æ¨¡å—æœªæˆæƒ
 799   3              }
 800   2          }else {
 801   2              //æµ‹è¯•æˆåŠŸ
 802   2              //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
 803   2          }
 804   1      }
 805          #endif
 806          
 807          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 15  

               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
                  }
              }
              #endif
 903          
 904          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 16  

               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
 924          
 925          #ifdef GET_WIFI_STATUS_ENABLE
              /**
               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
                      break;
                      
                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 17  

                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
 976          
 977          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 18  

                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
1041          
1042          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
              }
              #endif
1061          
1062          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
                  }
              }
              #endif
1086          
1087          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 19  

               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
1124          
1125          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
              }
              #endif
1144          
1145          #ifdef FILE_DOWNLOAD_ENABLE
              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 20  

               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
1187          
1188          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 21  

                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 22  

                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
1304          
1305          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
                  
                  unsigned char result = value[1];
                  unsigned char rssi = value[2];
                      
                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 23  

                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1344          
1345          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
                      break;
                      
                    default:break;
                  }
              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 24  

               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 25  

                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
C51 COMPILER V9.57.0.0   PROTOCOL                                                          03/10/2021 11:45:25 PAGE 26  

                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1563          
1564          
1565          
1566          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1225    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     44      57
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
